#include "CanFile.h"
#ifndef WIN32
#include <sys/times.h>
#include <unistd.h>
#endif
#include <limits.h>



//
// CanFile : encapsulates I/O of .can files
//
// Currently this class only supports output of CAN files, not input, since
// ICD has no use for CAN file input, at least now. 
//

#ifdef WIN32
// This hideously ugly hack is required because Microsoft Visual C++ 6.0
// does not properly implement the ANSI C++ standard regarding variables
// declared within 'for' statements.
#define for if(0) ; else for
#endif

extern struct tms beg_proc_times;
extern const char *version_info[];

using namespace std;

//
// output a CandidateList to a .can file
//
// filename : CAN file name for file generated by this routine
// peaks : CandidateList of candidates
// have_gt : is GT available for this image?
// truth : pointer to ImageTruth object, if GT is available
// image_filename : filename of original x-ray "source" (filename)
// img : x-ray image (necessary only to put # of rows and cols in CAN file)
// ds : subsample factor between coordinates in CandidateList and original image
// argc, argv : command line parameter variables, used to output debug info in CAN file
// max_can_count : maximum number of candidates that should be included in CAN file
//                 (if peaks has more than this number of candidates, only the first max_can_count are used)
//
void CanFile::write_can_file(char *filename, CandidateList *peaks, bool have_gt, ImageTruth *truth, 
                             string image_filename, const IemImage &img, int ds, int argc, char *argv[],
                             int max_can_count)
{
    ofstream os;

    os.open(filename);

    os << "#^CAN V1.1" << endl;
    os << "# File generated by CADx initial candidate detection" << endl;
    time_t clock_t = time(0);
    char *time_text = ctime(&clock_t);
    time_text[strlen(time_text)-1]=0;
    os << "#  on " << time_text << endl;

    os << "#  by ccICD compiled on " << __DATE__ << " " << __TIME__ << endl;

    os << "#" << endl;

    os << "#  run with the following command line parameters:" << endl;
    os << "#  ";

    for(int i=0; i<argc; i++)
        os << argv[i] << " ";
    os << endl;
    
    os << "#" << endl;
    os << "# Comments on this version of ccICD: " << endl;
    for(int i=0; version_info[i]; i++)
    {
        os << "# " << version_info[i] << endl;
    }
    os << "#" << endl;

	os << "# User space execution time: ";
#ifndef WIN32
    struct tms proc_times;
    times(&proc_times);

    os  << (proc_times.tms_utime - beg_proc_times.tms_utime) / float(sysconf(_SC_CLK_TCK)) << " sec" << endl;
#else
	os << "(not available when run on NT)" << endl;
#endif
    
    os << "#" << endl;

    os << "xraySourceID: " << image_filename << endl;
    os << "imageSize: " << img.cols() << " " << img.rows() << endl;

    int can_count;
    if(peaks->size() < max_can_count || !max_can_count)
        can_count = peaks->size();
    else
        can_count = max_can_count;

    os << "numCandidates: " << can_count << endl;

      // hard coded, for now.
    os << "typeRegion: b" << endl;
//    os << "numFeatures: " << Peak::FeatureCount << endl;
    os << "numFeatures: " << peaks->begin()->features.size() << endl;

    os << "flabels: ";

    map<string, double>::iterator feature_iter;
    for(feature_iter = peaks->begin()->features.begin(); feature_iter != peaks->begin()->features.end(); ++feature_iter)
        os << feature_iter->first << " ";
//    for(int i=0; i<Peak::FeatureCount; i++)
//        os << Peak::FeatureNames[i] << " ";

    os << endl;
    os << "endHeader:" << endl;

    os << "#" << endl;

      // Now loop through all candidates
    CandidateList::iterator peak_iter = peaks->begin();
    for(int i=0, can_num=0; peak_iter != peaks->end() && (!max_can_count || can_num < max_can_count); 
        peak_iter++, i++, can_num++)
    {
        os << "#" << endl;
        os << "candidateIndex: " << i << endl;

        const TrueNodule *tn;
        tn = truth->hit_test(Point(peak_iter->row * ds + ds / 2 - 1, 
                                   peak_iter->col * ds + ds / 2 - 1));

        Status status;

        if(have_gt)
        {
            if(tn)
                status = tn->get_status();
            else
                status = falsealarm;
        }
        else 
            status=unknown;

        os << "groundtruth: " << status << endl;
        double prob = peak_iter->get_probability();
        if(prob < 0) prob = 0;
        else if(prob > 1.0) prob = 1.0;
        os << "probability: " << prob << endl;

        os << "ftrVector: ";
        for(feature_iter = peak_iter->features.begin(); feature_iter != peak_iter->features.end(); ++feature_iter)
            os << feature_iter->second << " ";
//        for(int j=0; j<Peak::FeatureCount; j++)
//            os << peak_iter->features[j] << " ";
        os << endl;

        os << "centroid: " << peak_iter->col * ds + ds / 2 - 1
           << " " << peak_iter->row * ds + ds / 2 - 1 << endl;
        os << "nPoints: 0" << endl;

        os << "endCandidate:" << endl;
    }

    os.close();

}
